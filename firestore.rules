/**
 * @file Firebase Security Rules for Firestore.
 *
 * @core_philosophy This ruleset enforces a role-based access control model with specific restrictions on data access and modification. It also implements ownership-based access where applicable.
 * @data_structure
 *  - `/users/{userId}`: Stores user profile information; access is restricted to the user themselves.
 *  - `/categories/{categoryId}`: Stores document categories; write access is restricted to admins.
 *  - `/tags/{tagId}`: Stores document tags; write access is restricted to admins.
 *  - `/documents/{documentId}`: Stores document metadata; write access is restricted to admins, read access to public.
 *  - `/roles_admin/{userId}`: Indicates admin roles; write access is restricted. Admin role assignment should be handled via a trusted backend.
 * @key_security_decisions
 *  - Listing of all users is explicitly denied to protect user privacy.
 *  - Admin role assignment is secured.
 *  - Data consistency is enforced between user IDs in the path and the document data.
 * @denormalization_for_authorization
 *  - Admin status is determined by the existence of a document in the `/roles_admin/{userId}` collection.
 * @structural_segregation
 *  - Administrative roles are stored in a separate collection to enable secure filtering.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user's UID matches the provided userId.
     * @param {string} userId The user ID to compare against the authenticated user's UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

     /**
      * @description Determines if the requesting user is an admin by checking for the existence of a document in the /roles_admin/{userId} collection.
      * @return {boolean} True if the user is an admin, false otherwise.
      */
     function isAdmin() {
       return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
     }
    
    /**
     * @description Checks if the user is an existing owner of a document.
     * @param {string} userId The user ID to compare against the authenticated user's UID.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && existsAfter(/databases/$(database)/documents/users/$(userId));
    }

    /**
     * @description Defines security rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their own profile.
     * @allow (get) User with UID 'user123' can read their own profile.
     * @deny (update) User with UID 'user456' cannot update user 'user123' profile.
     * @deny (delete) User with UID 'user456' cannot delete user 'user123' profile.
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId); // Enforce immutability of userId
      allow delete: if isOwner(userId);
    }

    /**
     * @description Defines security rules for document categories.
     * @path /categories/{categoryId}
     * @allow (create) Admin user can create a category.
     * @allow (get) Any user can read a category.
     * @deny (update) Non-admin user cannot update a category.
     * @deny (delete) Non-admin user cannot delete a category.
     * @principle Restricts write access to admins.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Defines security rules for document tags.
     * @path /tags/{tagId}
     * @allow (create) Admin user can create a tag.
     * @allow (get) Any user can read a tag.
     * @deny (update) Non-admin user cannot update a tag.
     * @deny (delete) Non-admin user cannot delete a tag.
     * @principle Restricts write access to admins.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Defines security rules for documents.
     * @path /documents/{documentId}
     * @allow (create) Admin user can create a document.
     * @allow (get) Any user can read a document.
     * @deny (update) Non-admin user cannot update a document.
     * @deny (delete) Non-admin user cannot delete a document.
     * @principle Restricts write access to admins, allows public read.
     */
    match /documents/{documentId} {
      allow get, list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    /**
     * @description Defines security rules for admin roles.  This is a protected collection; admin role assignments should be performed by a trusted backend.
     * @path /roles_admin/{userId}
     * @deny (create) No one can directly create admin role documents.
     * @deny (get) No one can directly get admin role documents.
     * @deny (update) No one can directly update admin role documents.
     * @deny (delete) No one can directly delete admin role documents.
     * @principle Enforces that admin roles are managed by a trusted backend.
     */
    match /roles_admin/{userId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
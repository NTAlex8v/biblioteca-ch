/**
 * @fileoverview Firestore Security Rules for the virtual library application.
 *
 * Core Philosophy:
 * This ruleset implements a hybrid security model, balancing open read access for some collections with strict ownership and role-based access control for others.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, accessible to admins and the user themselves.
 * - /categories/{categoryId}: Public list of categories, managed by admins.
 * - /folders/{folderId}: Folders created by users for organizing documents, with ownership-based access.
 * - /tags/{tagId}: Public list of tags, freely available.
 * - /documents/{documentId}: Documents with metadata and file URLs, with ownership-based access.
 * - /auditLogs/{logId}: Global audit logs, accessible only to admins.
 *
 * Key Security Decisions:
 * - Listing all users is restricted to admins.
 * - Categories and Tags are publicly readable but admin-managed.
 * - User-generated content (folders, documents) is secured via ownership checks.
 * - Audit logs are restricted to admin access.
 *
 * Denormalization for Authorization:
 *  - Documents and Folders have a `createdBy` field to enable ownership-based rules without extra reads.
 *  - Users have a `role` field to define authorization level (Admin, Editor, User)
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants access to user profile information based on ownership or admin role.
     * @path /users/{userId}
     * @allow (read, write) if the user is an admin or owns the profile (userId matches auth.uid).
     * @deny (read, write) if the user is not an admin and does not own the profile.
     * @principle Enforces document ownership and role-based access for user profiles.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && (isAdmin() || isOwner(userId));
      allow list: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isSignedIn() && (isAdmin() || isExistingOwner(userId)) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && (isAdmin() || isExistingOwner(userId));
    }

    /**
     * @description Grants public read access to categories, but restricts write access to admins.
     * @path /categories/{categoryId}
     * @allow (get, list) to all users (public read).
     * @allow (create, update, delete) to admins only.
     * @deny (create, update, delete) to non-admins.
     * @principle Allows public discovery of categories, but restricts management to admins.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Grants access to folders based on ownership.
     * @path /folders/{folderId}
     * @allow (read, write) if the user owns the folder (createdBy matches auth.uid).
     * @deny (read, write) if the user does not own the folder.
     * @principle Enforces document ownership for folders.
     */
    match /folders/{folderId} {
      allow get, list: if isSignedIn() && isOwner(resource.data.createdBy);
      allow create: if isSignedIn() && isOwner(request.resource.data.createdBy);
      allow update: if isSignedIn() && isExistingOwner(resource.data.createdBy) && request.resource.data.createdBy == resource.data.createdBy;
      allow delete: if isSignedIn() && isExistingOwner(resource.data.createdBy);
    }

    /**
     * @description Grants public read access to tags, but restricts write access to admins.
     * @path /tags/{tagId}
     * @allow (get, list) to all users (public read).
     * @allow (create, update, delete) to admins only.
     * @deny (create, update, delete) to non-admins.
     * @principle Allows public discovery of tags, but restricts management to admins.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    /**
     * @description Grants access to documents based on ownership.
     * @path /documents/{documentId}
     * @allow (read, write) if the user owns the document (createdBy matches auth.uid).
     * @deny (read, write) if the user does not own the document.
     * @principle Enforces document ownership for documents.
     */
    match /documents/{documentId} {
      allow get, list: if isSignedIn() && isOwner(resource.data.createdBy);
      allow create: if isSignedIn() && isOwner(request.resource.data.createdBy);
      allow update: if isSignedIn() && isExistingOwner(resource.data.createdBy) && request.resource.data.createdBy == resource.data.createdBy;
      allow delete: if isSignedIn() && isExistingOwner(resource.data.createdBy);
    }

    /**
     * @description Restricts access to audit logs to admins only.
     * @path /auditLogs/{logId}
     * @allow (read, write) to admins only.
     * @deny (read, write) to non-admins.
     * @principle Enforces role-based access control for audit logs.
     */
    match /auditLogs/{logId} {
      allow get, list: if isSignedIn() && isAdmin();
      allow create: if isSignedIn() && isAdmin();
      allow update: if isSignedIn() && isAdmin();
      allow delete: if isSignedIn() && isAdmin();
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId) && resource != null;
    }

    function isAdmin() {
      return isSignedIn() && request.auth.token.role == 'Admin';
    }
  }
}
/**
 * @fileoverview Firestore Security Rules for the virtual library application.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure data access based on user roles and ownership.
 * It implements an Admin-centric model for managing categories and a user-ownership model for folders and documents.
 * All list operations on user-owned data are restricted to the owning user.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles; `userId` matches the Firebase Auth UID.
 * - /categories/{categoryId}: Stores global categories, managed by admins.
 * - /folders/{folderId}: Stores folders created by users within categories.
 * - /tags/{tagId}: Stores global tags, managed by admins.
 * - /documents/{documentId}: Stores document metadata and links.
 * - /auditLogs/{logId}: Stores audit logs. Only admins have read access.
 *
 * Key Security Decisions:
 * - User listing is disallowed to prevent enumeration.
 * - Categories and Tags are globally readable but creatable/manageable only by admins.
 * - Documents and Folders are owned by users, who have full CRUD access.
 * - Audit logs are readable only by admins.
 * - Write operations are strictly controlled and validated against user identity and roles.
 *
 * Denormalization for Authorization:
 *  Ownership checks rely on the `createdBy` field in Folder and Document entities, and the document ID matching the `userId` for User entities.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rule for the root.
     * @path /
     * @allow (get, list) if false
     * @deny (create, update, delete) if false
     * @principle Root access is denied.
     */
    match /{document=**} {
      allow read, write: if false;
    }

    /**
     * @description Rules for user profile documents.
     * @path /users/{userId}
     * @allow (create) User with matching UID can create their own profile.
     * @allow (get, update, delete, list) User with matching UID can get, update, delete, and list their own profile.
     * @deny (create) if the user ID doesn't match the authenticated user ID.
     * @deny (update, delete) if the user is not the owner.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for top-level categories.
     * @path /categories/{categoryId}
     * @allow (get, list) Public access for reading categories.
     * @allow (create, update, delete) Admins can create, update, and delete categories.
     * @deny (create, update, delete) Non-admins cannot modify categories.
     * @principle Admin-only management of categories with public read access.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for user-created folders.
     * @path /folders/{folderId}
     * @allow (create) User can create a folder if they are authenticated.
     * @allow (get, list, update, delete) User can manage their own folders.
     * @deny (create) if the user is not authenticated.
     * @deny (update, delete) if the user is not the owner.
     * @principle Enforces document ownership for folder management.
     */
    match /folders/{folderId} {
      allow get, list: if isOwnerOfFolder(resource.data.createdBy);
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isExistingOwnerOfFolder(resource.data.createdBy);
      allow delete: if isExistingOwnerOfFolder(resource.data.createdBy);
    }

    /**
     * @description Rules for global tags.
     * @path /tags/{tagId}
     * @allow (get, list) Public access for reading tags.
     * @allow (create, update, delete) Admins can create, update, and delete tags.
     * @deny (create, update, delete) Non-admins cannot modify tags.
     * @principle Admin-only management of tags with public read access.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rules for documents.
     * @path /documents/{documentId}
     * @allow (get, list) Public access for reading documents.
     * @allow (create) User can create a document if they are authenticated and set createdBy to their UID.
     * @allow (update, delete) User can manage their own documents.
     * @deny (create) if the user is not authenticated or the createdBy field doesn't match their UID.
     * @deny (update, delete) if the user is not the owner.
     * @principle Enforces document ownership for document management.
     */
    match /documents/{documentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isExistingOwnerOfDocument(resource.data.createdBy);
      allow delete: if isExistingOwnerOfDocument(resource.data.createdBy);
    }

      /**
       * @description Rules for global audit logs. Only admins can access
       * @path /auditLogs/{logId}
       * @allow (get, list) if the user is an admin.
       * @deny (create, update, delete) if the user is not an admin.
       * @principle Only admins can manage audit logs.
       */
    match /auditLogs/{logId} {
      allow get, list: if isAdmin();
      allow create, update, delete: if false;
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }

  function isAdmin() {
     return request.auth.token.role == 'Admin';
  }

    function isOwnerOfFolder(createdBy) {
    return request.auth.uid == createdBy;
  }

  function isExistingOwnerOfFolder(createdBy) {
    return isOwnerOfFolder(createdBy) && resource != null;
  }

    function isOwnerOfDocument(createdBy) {
    return request.auth.uid == createdBy;
  }

  function isExistingOwnerOfDocument(createdBy) {
    return isOwnerOfDocument(createdBy) && resource != null;
  }
}
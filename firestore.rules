/**
 * @fileoverview Firestore Security Rules for the virtual library app.
 *
 * Core Philosophy:
 * This ruleset prioritizes ease of iteration during the prototyping phase, focusing on
 * strong authentication and access control while relaxing schema validation.
 * It implements a mixed security model: public read access for 'documents' and 'categories',
 * and owner-only write access for 'users', 'folders', and 'documents'.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, with the userId matching the Firebase Auth UID.
 * - /categories/{categoryId}: Stores global categories.
 * - /folders/{folderId}: Stores user-created folders within categories.
 * - /tags/{tagId}: Stores global tags.
 * - /documents/{documentId}: Stores document metadata and file URLs.
 *
 * Key Security Decisions:
 * - Users can only read and write their own user profiles.
 * - Documents and Categories are publicly readable.
 * - Only authenticated users can create, update, or delete documents and folders.
 * - The exact schema of the data being written is NOT strictly enforced to allow for rapid iteration.
 *
 * Denormalization for Authorization:
 * - Documents have a 'createdBy' field that must match the user's UID for write access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user ID matches the authenticated user's UID.
     * @param {string} userId The user ID to check.
     * @return {boolean} True if the user ID matches the authenticated user's UID, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user ID matches the authenticated user's UID and the resource exists.
     * @param {string} userId The user ID to check.
     * @return {boolean} True if the user ID matches the authenticated user's UID and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }


    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) Authenticated user can create their own profile if the userId matches their auth UID.
     * @allow (get, list, update, delete) Authenticated user can only access their own profile.
     * @deny (create) User cannot create a profile with a different userId.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Explicitly disallow listing users.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Enforce immutability of userId on updates.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for global categories. Publicly readable, admin-only writeable.
     * @path /categories/{categoryId}
     * @allow (get, list) Anyone can read categories.
     * @allow (create, update, delete) Only admins can modify categories.
     * @deny (create, update, delete) Non-admins cannot modify categories.
     * @principle Allows public reads, restricts writes to admins.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation once the schema is updated with an admin role.
    }
    /**
     * @description Rules for user-created folders. Owner-only access.
     * @path /folders/{folderId}
     * @allow (create) Authenticated user can create folders.
     * @allow (get, list, update, delete) Only the folder creator can access/modify the folder.
     * @deny (create) Non-authenticated users cannot create folders.
     * @deny (update, delete) Users cannot modify folders they don't own.
     * @principle Enforces document ownership for writes.
     */
    match /folders/{folderId} {
      allow get: if isSignedIn() && resource.data.createdBy == request.auth.uid;
      allow list: if isSignedIn() && resource.data.createdBy == request.auth.uid;
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isExistingOwner(resource.data.createdBy) && request.resource.data.createdBy == resource.data.createdBy; // Enforce immutability of creatorId on updates.
      allow delete: if isExistingOwner(resource.data.createdBy);
    }

    /**
     * @description Rules for global tags.
     * @path /tags/{tagId}
     * @allow (get, list) Anyone can read tags.
     * @allow (create, update, delete) Only admins can modify tags.
     * @deny (create, update, delete) Non-admins cannot modify tags.
     * @principle Allows public reads, restricts writes to admins.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin validation once the schema is updated with an admin role.
    }

    /**
     * @description Rules for documents. Publicly readable, owner-only writeable.
     * @path /documents/{documentId}
     * @allow (get, list) Anyone can read documents.
     * @allow (create) Only authenticated users can create documents, with creatorId matching their UID.
     * @allow (update, delete) Only the document creator can modify the document.
     * @deny (create) Non-authenticated users cannot create documents.
     * @deny (update, delete) Users cannot modify documents they don't own.
     * @principle Allows public reads, enforces document ownership for writes.
     */
    match /documents/{documentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.createdBy == request.auth.uid;
      allow update: if isExistingOwner(resource.data.createdBy) && request.resource.data.createdBy == resource.data.createdBy; // Enforce immutability of creatorId on updates.
      allow delete: if isExistingOwner(resource.data.createdBy);
    }
  }
}
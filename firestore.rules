/**
 * @file Firebase Security Rules for Firestore.
 * @version 2
 *
 * @description
 * This ruleset enforces a strict user-ownership model for user profiles and public read access with owner-only writes for all other collections.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Only the authenticated user can read and write their own profile.
 * - /categories/{categoryId}: Stores categories. Public read, owner-only write.
 * - /tags/{tagId}: Stores tags. Public read, owner-only write.
 * - /documents/{documentId}: Stores documents. Public read, owner-only write.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data. No listing of all users is allowed.
 * - Categories, tags, and documents are publicly readable but writable only by an owner.
 * - Data validation is limited to ownership checks for relational integrity and is kept flexible for prototyping.
 *
 * Denormalization for Authorization:
 *   The rules rely on an `ownerId` or `authorId` field on the documents within the `/categories`, `/tags`, and `/documents` collections. This field MUST match the UID of the user attempting to create, update, or delete the document.
 *
 * Structural Segregation:
 *   This ruleset uses top-level collections for both public and private data. User profiles are stored under `/users/{userId}`, allowing strict access control. Documents, categories, and tags are stored in top-level collections to enable public read access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own user profile.
     * @path /users/{userId}
     * @allow (create, update, delete, get): Authenticated user with matching UID.
     * @deny (create, update, delete, get): Authenticated user with non-matching UID. Unauthenticated users.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      // Validate that userId (from path) matches the authenticated user's uid.
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      // Validate that userId (from path) matches the authenticated user's uid and the document exists.
      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
      }

      // Check if the user is signed in
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Disable listing of all users.
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to categories, but restricts write access to owners.
     * @path /categories/{categoryId}
     * @allow (get, list): Any user (public read).
     * @allow (create, update, delete): Authenticated user with matching authorId.
     * @deny (create, update, delete): Unauthenticated users, or authenticated users with non-matching authorId.
     * @principle Public read access with owner-only writes.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && request.resource.data.authorId == request.auth.uid && resource.data.authorId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Allows public read access to tags, but restricts write access to owners.
     * @path /tags/{tagId}
     * @allow (get, list): Any user (public read).
     * @allow (create, update, delete): Authenticated user with matching authorId.
     * @deny (create, update, delete): Unauthenticated users, or authenticated users with non-matching authorId.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && request.resource.data.authorId == request.auth.uid && resource.data.authorId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Allows public read access to documents, but restricts write access to owners.
     * @path /documents/{documentId}
     * @allow (get, list): Any user (public read).
     * @allow (create, update, delete): Authenticated user with matching authorId.
     * @deny (create, update, delete): Unauthenticated users, or authenticated users with non-matching authorId.
     * @principle Public read access with owner-only writes.
     */
    match /documents/{documentId} {
      allow get, list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && request.resource.data.authorId == request.auth.uid && resource.data.authorId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.authorId == request.auth.uid;
    }
  }
}